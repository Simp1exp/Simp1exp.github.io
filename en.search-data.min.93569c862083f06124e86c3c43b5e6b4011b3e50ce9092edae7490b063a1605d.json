[{"id":0,"href":"/posts/introduction/","title":"Introduction","section":"Posts","content":"How this post is going to work? #  This post intends to bring a review of the course “Exploiting and Securing Vulnerabilities in Java Applications” available on Coursera, eventually, I also intend to bring some additional information. The dynamic of the post will be the same as the course, it’ll begin with an explanation about the topic, followed by a practical exercise trying to find the vulnerability, much like a CTF, and finally, explain how to fix it.\nOBS1: The only exception to this rule is the fourth week. Due to the content and length, doesn’t make sense to follow this structure.\nI don’t think is necessary to teach how to set the environment, since the instructor has a group of videos explaining this step-by-step. The important thing to know is that we’ll be using Webgoat, as said by the creators of the app: “WebGoat is a deliberately insecure application that allows interested developers just like you to test vulnerabilities commonly found in Java-based applications that use common and popular open-source components.”\nOBS2: Srry! I had to resize images to fit the screen properly and also make the website faster. If the images look a little blurry, what you can do is zoom in or open the image in another tab.\n"},{"id":1,"href":"/posts/week-1/","title":"Week 1","section":"Posts","content":"XSS #  What’s this? #   Cross Site Scripting or XSS is a type of injection attack. All injection attacks consist in using the input field that the application provides to enter arbitrary data. In the XSS case, the arbitrary data is normally written in JavaScript, but may also include HTML, Flash, or any other type of code that the browser may execute. There are three types of XSS: Reflected, Stored, and DOM-Based. In this course, we only learn about the first and the second one, for these, the events happen in this order:  The arbitrary data is sent to the server The server processes the data and returns it back to the user When this web page code arrives, the browser reads it and triggers the non-sanitized code embedded in the web page.    The only difference between Reflected and Stored XSS is the second step. As the name suggests, in the first one the code returns to the user but it’s not stored in the server and it only happens when the user sends the request to the server. The second is much more dangerous because it happens with everyone who enters the web page.\nReflected XSS #  Example:\n This is an application in WebGoat that demonstrates how Reflected XSS works. See the value “I’m here” in the input field is reflected on the web page? This indicates our application may be vulnerable. To test the application, we need to input a payload, in this case, I’m using \u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt;. Now we are certain the application is vulnerable. Ok, this is cool and all but we can’t do much with it. Generally, reflected XSS can do bad things when the data reflected can be embedded in the URL.\nExample:\n Notice when we search for “test” a message is returned saying “0 search results for ‘test’”, this means the value that we inputted is being reflected on our web page, which means this site may be vulnerable to Reflected XSS. Is also important to notice there is a search parameter passing “test” as a value in the URL bar. This shows that if this input field is vulnerable to Reflected XSS, it can be exploited by sending crafted URLs leading to user accounts being hijacked, credentials stolen, sensitive data exfiltrated, and lastly, access to your client computers can be obtained.\nNow we need to test to see if this site is vulnerable.\nPerfect! We did it.\tNow we can craft URLs with payloads in the search parameter and use some kind of social engineer in order to make someone click it.\nAs was said, Stored XSS is much more dangerous because the payload is stored in the server. Knowing how XSS works and specifically, how Stored XSS works, it’s obvious to think that this type of vulnerability may happen with a common feature, that fulfills all prerequisites, like a comment section. An important thing to mention is that here, there is no need for the reflected value to be passed via URL parameter to be dangerous.\nStored XSS #  Example:\nThe comment added was: \u0026lt;script\u0026gt;alert(“try it 2”)\u0026lt;/script\u0026gt;. Again, every time someone access this page the script is going to be executed in their browser.\nHow to fix it? #   Both reflected and stored XSS can be fixed by performing the appropriate validation and encoding on the server-side. The best way to provide this proper validation and encoding is, as OWASP recommends, using a security-focused encoding library to make sure these rules are properly implemented.  Reflected fix: #  My intention in showing this again is to clarify the next steps.\n This is called Burp suite. Burp, as we kindly name it, is a proxy. Ok, but what is a proxy? A proxy is something that seats between you and the server you trying to access. Burp intercepts the traffic between your browser and the server you’re communicating with to show exactly how this communication is happening. See that field1=%3Cscript%3Ealert(document.domain)%3C%2Fscript%3E in the URL parameter? You don’t need to worry, it’s just what we inputted in the credit card number field but it’s URL encoded.\nThe value of that “field1” parameter in the last image is being assigned to a “field1” variable and this variable is used to create a message that will return to the user. The problem is that this variable is not being sanitized, which causes the XSS.\nWhat is happening? We’re simply HTML encoding this string \u0026lt;script\u0026gt;alert(document.domain)\u0026lt;/script\u0026gt; in the variable “field1” to \u0026amp;lt;script\u0026amp;gt;alert(document.domain)\u0026amp;lt;/script\u0026amp;gt;.\n It won’t be executed anymore.\nStored fix: #  The exact same fix is used in here.  "},{"id":2,"href":"/posts/week-2/","title":"Week 2","section":"Posts","content":"Injection Attacks #  What’s this? #   Injection attacks are a class of attacks that consists of supplying untrusted input to a program. The objective is to get an exception case that triggers something, from there understand how this input is being sanitized, and then craft a payload. Between the vulnerabilities that fit in this category, SQLi (SQL Injections) and XXE (XML External Entity) are what we’re going to learn in this class  SQL Injection #  What’s this? #  SQL Injection(SQLi) attack is a code injection technique used to attack data-driven applications. This type of application, in general, uses SQL databases to store information making it possible to insert arbitrary SQL statements. Once bypassing these filters it’s possible to modify and read data from the database. To completely understand SQLi I suggest learning the SQL.\nStructured Query Language(SQL) is a language designed for managing data held in a relational database management system. This is what a query looks like:\nSELECT population FROM world WHERE name = \u0026quot;France\u0026quot;\nThis is the basics of SQL, which is like a \u0026ldquo;hello world\u0026rdquo; in other programming languages.\nOk, back to SQLi, now we’re going to see what a vulnerable application looks like. This is a Challenge from Webgoat:\nBesides “Register” there is also a tab called “Login”, but it doesn’t matter for now.\nIntercepting the request with “burp” we see a parameter called “username_reg” with the value “teste”\nThis first piece of code in the “registerNewUser” method is using the username to check if this user is already registered. The parameter in the PUT request is passed to a variable, also called “username_reg”, after that, in red, this variable is concatenated to another string to form a query and this query is placed in another variable called “checkUserQuery”. I logged the value of this string to show what the value of this string is. Remember, this string is going to be executed in the database.\nOk, but is this vulnerable? Because the string is being concatenated, we can modify the structure of this query.\nSee? This is saying the user “teste’or’1’=’1’—” already exists. This user wasn’t created, so how we’re having this output?\n That input we placed in the form formed this query. With a basic understanding of SQL, you can understand that this is always true. Regardless of the userid, we won’t be able to register a new account. Ok, but how can we exploit this SQLi vulnerability to dump the database, discover user passwords, and so on? Well, this is up to your imagination and understanding of SQL. My goal here is to teach about SQL and how to fix it. Not how to exploit it.\nHow to fix it? #  In the course is said about something called parameterized strings or a prepared statement. What you need to know is that this thing ensures the crafted data we send won’t interfere with the structure of the query. Because the query structure has already been defined, the relevant API handles any type of placeholder data safely, so it is always interpreted as data rather than part of the statement’s structure.\nRemember I said the login form didn’t matter for us back then? This is why. Since this code is secure, it couldn’t be used as an example.\nXML External Entity #  What’s this? #  XXE is also a code injection technique, but different from SQLi, your target is applications that parse XML input. OK, but what is XML? XML is a markup language similar to HTML, it’s generally used to handle data in a standard structure. This language is used in a ton of places such as APIs, UI layouts \u0026amp; styles in android applications, and config files of various frameworks. It looks something like this:\nIt’s important to mention that XML has something called entities that are like variables and these variables are defined in a separate part of the document, called Document type definition (DTD).\nThis “ENTITY” in the DTD has a property called “SYSTEM\u0026quot; that allows assigning external content to a variable. That is where the name XML external entity comes from.\nKnowing only this is enough to perform an XXE, more precisely, an in-band one. So, what’s an in-band XXE? It’s when the XML is parsed and the output is shown on the screen.\nExample: Here is what the actual communication looks like. It’s important to notice the Content-Type as well, depending on how the application is implemented, the header might tell the framework how to parse this body.\nWhat is happening here is that we’re creating an external entity called “test” that refers to a “.”, this dot represents the current directory. After creating this entity, we call it in the \u0026lt;text\u0026gt; tag. This tag carries what’s shown in the comment section.\nHow to fix it? #  The way the instructor solved this lab was by configuring the framework to ignore DTD since the application doesn’t use this XML feature, although sometimes you need internal entities, but not external ones. When this happens, it might be possible to configure the framework you’re using to disable it.\n"},{"id":3,"href":"/posts/week-3/","title":"Week 3","section":"Posts","content":"Authentication and Authorization #  What’s this? #  These two are similar in the sense that they guarantee privacy, but they’re also different. Authentication is who you claim to be. Authorization is what you’re allowed to do.\nIn this course, authorization is only defined but not explored further to how these policies are ensured. So, some things like the access control model, vertical and horizontal escalation aren’t mentioned. Since my intention isn’t to go out of the scope of this course, I won’t talk about it.\nAuthentication #  What’s this? #  Authentication is a process that responds to a key question. You’re who you claim to be? There are various types of processes we know and use every day to authenticate ourselves in different systems. We can categorize them into three different types.\n  Something you have. This type of authentication mechanism can be something like a phone. It’s important to be something physical, otherwise ‘Something you have’ and ‘Something you know’ tend to intertwine at some point.\n  Something you know. An example would be a password, a security question, etc…\n  Something you are. Here a good example is your biometrics.\n  It’s important to notice, in a system that requires authentication, you can have multiple of these in the same category, but for it to be a 2FA(two-factor authentication) or 3FA(three-factor authentication), there must have at least one of them. One example is your Steam that implements a 2FA, in their case, there is a common login form, followed by a code you get from your mobile device. We’re going to see next one of the most common vulnerabilities that an authentication system has, logic flaws.\nThere are 2 security questions passed via a post request. In a real scenario where you don’t have access to the source code. To test this feature, you would have to fuzz all these parameters trying to find something that pops an error or you can be lucky and pops exactly what you’re looking for.\nIn this case, we already know this application is insecure and we don’t want to spend time fuzzing it. Our goal here is to understand what is happening, so let’s go to the code and see what it does.\nHere is the code responsible for all we need to know. The first thing that we notice is that our answers to those questions are being parsed by a custom function called “parseSecQuestions”, which makes obvious what it does. We already know that custom features are dangerous when not tested intensively. Ok, this method seems interesting. Now, how does it parse the SecQuestions? This function receives the request as a parameter and returns a data structure called hash map(it’s like a dictionary in python), it works with a key: value pair, in this case, String Key: String Value. But, you see, there is a for loop to pass through all parameters and see the ones that contain the string “secQuestion” and if it contains, adds it to the dictionary. Knowing this, our hash map might look something like this {“secQuestion0”: “test”, “secQuestion1”: ”test”}. After we returned the Hash map, there is a method called “didUserLikelyCheat”. I’m not going to dig deep into it, but basically, these checks if the answer to secQuestion0 and secQuestion1 are the ones hardcoded. Next to this method, we have another method called “verifyAccount” inside an if statement that, when true, returns to us a “.feedback(“verify-account.success”)”, plus the parameters of this method are “userId” and the previous parsed HashMap. Ok, this is what we want. Let’s see what the code looks like.\nThe goal here is to return true, for that, we need to craft a payload that passes through all these conditions without triggering none of them. The first “if” checks if we’re sending the same number of “secQuestion” parameters that the correct request should have, which is 2. The second and the third check if there is a parameter called “secQuestion0” and “secQuestion1” respectively, and after that, it uses an and gate(\u0026amp;\u0026amp;). Knowing all of this is easy to come up with a proper request, something like this should do the job:\n How to fix it? #  The right way to fix this would be by using a trusted framework, instead of doing this custom logic. In this lesson, the professor fixes this code rewriting it more safely, using concepts like “Fail closed” which ensures that if there is an edge case, it won’t return true.\npublic boolean verifyAccount(Integer userId, HashMap\u0026lt;String,String\u0026gt; submittedQuestions ) { if (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId.size()) { return false; } if (submittedQuestions.containsKey(\u0026quot;secQuestion0\u0026quot;) \u0026amp;\u0026amp; subnittedQuestions.get(\u0026quot;secQuestion0\u0026quot;).equals(secQuestionStore.get(verifyUserId).get(\u0026quot;secQuestion0\u0026quot;))){ return true; } if (submittedQuestions.containsKey(\u0026quot;secQuestionl\u0026quot;) \u0026amp;\u0026amp; subnittedQuestions.get(\u0026quot;secQuestionl\u0026quot;).equals(secQuestionStore.get(verifyUserId).get(\u0026quot;secQuestion1\u0026quot;))){ return true; } return false; } JWT #  What’s this? #  JSON Web Token(JWT) is a secure and trustworthy standard for token authentication. Token authentication is an approach to persist the identity of a user after the initial authentication process. It ensures users don\u0026rsquo;t need to place their credentials every time they want to act.\nThe JWT anatomy is:\nIt’s a long-encoded string with a total of 3 sections separated by dots. The reason for being encoded is simple. It prevents the JWT from breaking applications that don’t allow specific characters. See the last part, the “verify signature”? “foo” is a secret key used to encrypt the message using the HMACSHA512 hash algorithm, this guarantees the integrity of the massage. That way the payload can contain things like “admin”: false, and even if you use a proxy to intercept the HTTP request and change the value “admin”: true, it won’t work.\nJust to clarify, here’s the basic sequence of getting a token:\nHere is the example of JWT vulnerability used in the class:\nOur goal is to reset the votes, and for that, we need to be an admin.\nHere is the request responsible for resetting all votes. Se the “access_token”? By the structure we can tell already, this is a JWT. So, let’s decode it.\nThis is what we get when base64 decoding the message. There are several ways on how this JWT may be vulnerable, but the one chosen for this lab consists in changing the algorithm type to none. So, we just need to change the algorithm to none, the admin to true, and remove the tail from the JWT.\nUsing that same formula base64(header) + “.” + base64(payload) + “.” + base64(signature), we can create our modified JWT. It’s important to point out that when using a none algorithm, the signature part is erased and the “.” stays. Looks something like this: “eyJhbGciOiJub25lIn0=.eyJpYXQiOjE2NDc2MTMzODQsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9.”\nHow to fix it? #  This issue happens because there is no verification on the received algorithm. Then, what we need to do is, verify if the algorithm is the same we expect it to be.\nThe parse method is the one causing all of this, its purpose should be to parse JWT. The thing is, JWT doesn’t need necessarily to be signed. Seeing that this parse method doesn’t do exactly what we’re looking for, we should use another parser, one that parses signed JWT or what\u0026rsquo;s called JWS.\n"},{"id":4,"href":"/posts/week-4/","title":"Week 4","section":"Posts","content":"Dangers of Vulnerable Components Introduction #  This week has much less content in comparison to the others. It focuses more on identifying flaws in your dependencies and updating them.\nOne tool used by the instructor is called dependency check by OWASP and it scans your project and returns a report with all the dependencies listed and categorizes one by one, saying if they’re vulnerable, if so, it also gives a link to a known CVE.\nThe command line to scan your projects folder is: dependency-check –scan \u0026lt;path-to-the-folder\u0026gt;\n"}]